<!DOCTYPE html>
<html
<head>
    <meta charset="UTF-8">
    <script type="text/javascript">
        
        // Part G. Float precision
        var a=0.1, b=0.2;
        console.log("0.1 + 0.2 == " + (a+b) );
        console.log("0.1 + 0.2 == 0.3 is " + ((a+b)==0.3) );
        console.log("(0.1 + 0.2).toPrecision(10) == 0.3 is " + ((0.1 + 0.2).toPrecision(10) == 0.3) );
        console.log("(0.1 + 0.2).toFixed(10) == 0.3 is " + ((0.1 + 0.2).toFixed(10) == 0.3) );
        console.log("^^^^^^^^^^ Part G. Float precision ^^^^^^^^^^^^^^^^");

        
        // Part I. IIEF revisit -- new
        var Man = (function () {
                var localInit=function(age){
                    this.sex="male";
                    this.age=age;   
                };
                return{
                    ManInit:localInit   
                }
        }());
        var m1=Man.ManInit(20);
        var m2=new Man.ManInit(21);
        console.log(m1);                        //undefined... from func def.   
        console.log(window.sex);                //undefined......>>>no pollution in the global scope.
        console.log(m2.sex+' '+m2.age);         //male 21  
        console.log("^^^^^^^^^^ Part I. IIEF revisit -- new ^^^^^^^^^^^^^^^^");
        
        
        // Part J. new
        function Man2(age){
            this.sex="male";
            this.age=age;
        };
        var m11=Man2(20);
        var m22=new Man2(21);               //instance of Man2
        console.log(m11);                   //undefined
        console.log(window.sex);            //male, global polluted.
        console.log(m22.sex+' '+m22.age);   //male 21
        console.log("^^^^^^^^^^ Part J. new ^^^^^^^^^^^^^^^^");
        
        
        // Part K. new factory
        function Man3(age){
            var obj=new Object();
            obj.sex="male";
            obj.age=age;
            return obj;
        };
        var m111=Man3(20);
        console.log(m111.sex+' '+m111.age);   //male 20
        console.log("^^^^^^^^^^ Part K. new factory ^^^^^^^^^^^^^^^^");
        
        
        // Part M. New operator -- a. function without return value.
        //  如果就一个函数，没有返回值，没有prototype成员，然后使用new,会是什么结果呢？
        //  如果一个函数没有返回值，那么如果不使用new来创建变量，那么该变量的值为undefined.
        //  如果用了new，那么就是Object.说明一个函数的默认的Prototype是Object.
        function Test1(str) {
            this.a = str;
        }
        var myTest = new Test1("test1");
        console.log(myTest); //[object Object]
        function Test1WithoutNew(str) {
            this.a = str;
        }
        var myTestWithoutNew = Test1WithoutNew("test1");
        console.log(myTestWithoutNew); //undefined;
        console.log("^^^^^^^^^^ Part M. New operator -- a. function without return value. ^^^^^^^^^^^^^^^^");
        
        
        // Part M. New operator -- b. function with return value.
        //  如果函数有返回值，但是返回值是基本类型。那么new出来的myTest还是object.
        //  因为基本类型的prototype还是Object.
        //  而如果不使用new，那么返回值就是string的值。
        function Test2(str) {
            this.a = str;
            return this.a;
        }
        var myTest = new Test2("test1");
        console.log(myTest); //Object
        function Test2WithoutNew(str) {
            this.a = str;
            return this.a;
        }
        var myTestWithoutNew2 = Test2WithoutNew("test1");
        console.log(myTestWithoutNew2); //"test1"
        console.log("^^^^^^^^^^ Part M. New operator -- b. function with return value. ^^^^^^^^^^^^^^^^");
        
        
        // Part M. New operator -- c. function with return new value.
        //  如果函数的返回值为new出来的对象，那么myTest的值根据new出来的对象的prototype而定。
        function Test3(str) {
            this.a = str;
            return new String(this.a);
        }
        var myTest = new Test3("test2");
        console.log(myTest); //String "test2"
        console.log("^^^^^^^^^^ Part M. New operator -- c. function with return new value. ^^^^^^^^^^^^^^^^");
        
        
        // Part N. JS OO -- a. factory.
        // 工厂模式是软件工程领域一种广为人知的设计模式，而由于在ECMAScript中无法创建类，因此用函数封装以特定接口创建对象。
        // 其实现方法非常简单，也就是在函数内创建一个对象，给对象赋予属性及方法再将对象返回即可。
        function createBlog(name, url) {
          var o = new Object();
          o.name = name;
          o.url = url;
          o.sayUrl= function() {
            console.log(this.url);
          }
          return o;
        }
        var blog1 = createBlog('ZZZ', 'http://www.zzz.net/');
        blog1.sayUrl(); 
        //可以看到工厂模式的实现方法非常简单，解决了创建多个相似对象的问题，但是工厂模式却无从识别对象的类型，
        //因为全部都是Object，不像Date、Array等，因此出现了构造函数模式。
        console.log("^^^^^^^^^^ Part N. JS OO -- a. factory ^^^^^^^^^^^^^^^^");


        // Part N. JS OO -- b. contructor.
        // 构造函数模式: ECMAScript中构造函数可以创建特定类型的对象，类似于Array、Date等原生JS的对象。其实现方法如下：
        function Blogger(name, url) {
          this.name = name;
          this.url = url;
          this.alertUrl = function() {
            console.log(this.url);
          }
        }
        var blog = new Blogger('AAA', 'http://www.AAA.net/');
        console.log(blog instanceof Blogger);  // true， 判断blog是否是Blog的实例，即解决了工厂模式中不能     
        //这个例子与工厂模式中除了函数名不同以外，细心的童鞋应该发现许多不同之处：
        //函数名首写字母为大写　　（虽然标准没有严格规定首写字母为大写，但按照惯例，构造函数的首写字母用大写
        //没有显示的创建对象
        //直接将属性和方法赋值给了this对象
        //没有return语句
        //使用new创建对象
        //能够识别对象（这正是构造函数模式胜于工厂模式的地方）
        //构造函数虽然好用，但也并非没有缺点，使用构造函数的最大的问题在于每次创建实例的时候都要重新创建一次方法（
        //理论上每次创建对象的时候对象的属性均不同，而对象的方法是相同的），然而创建两次完全相同的方法是没有必要的，
        //因此，我们可以将函数移到对象外面（也许有些童鞋已经看出缺点，嘘！）。
        function Blogger2(name, url) {
          this.name = name;
          this.url = url;
          this.alertUrl = alertUrl;
        }    
        function alertUrl() {
          console.log(this.url);
        }
        var blog = new Blogger2('BBB', 'http://www.bbb.net/'),
        blog2 = new Blogger2('CCC', 'http://www.ccc.net/');
        blog.alertUrl();  // http://www.bbb.net/
        blog2.alertUrl();  // http://www.ccc.net/
        //我们将alertUrl设置成全局函数，这样一来blog与blog2访问的都是同一个函数，可是问题又来了，
        //在全局作用域中定义了一个实际只想让Blog使用的函数，显示让全局作用域有些名副其实，
        //更让人无法接受的是在全局作用域中定义了许多仅供特定对象使用的方法，浪费空间不说，
        //显然失去了面向对象封装性了，因此可以通过原型来解决此问题。
        console.log("^^^^^^^^^^ Part N. JS OO -- b. contructor ^^^^^^^^^^^^^^^^");

        
        // Part N. JS OO -- c. prototype.
        //原型模式: 我们创建的每个函数都有prototype（原型）属性，这个属性是一个指针，指向一个对象，
        //而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。
        //使用原型对象的好处就是可以让所有对象实例共享它所包含的属性及方法。
        function Blog3() {
        }
        Blog3.prototype.name = 'AAA';
        Blog3.prototype.url = 'http://tools.aaa.net/';
        Blog3.prototype.friend = ['fr1', 'fr2', 'fr3', 'fr4'];
        Blog3.prototype.alertInfo = function() {
          console.log(this.name + this.url + this.friend );
        }
        // 以下为测试代码
        var blog = new Blog3(),
        blog2 = new Blog3();
        blog.alertInfo();  // AAAhttp://tools.aaa.net/fr1,fr2,fr3,fr4
        blog2.alertInfo();  // AAAhttp://tools.aaa.net/fr1,fr2,fr3,fr4
        
        blog.name = '1';
        blog.url = 'http://***.com';
        blog.friend.pop();
        blog2.name = '2';
        blog2.url = 'http://+++.com';
        blog.alertInfo();  // 1http://***.comfr1,fr2,fr3
        blog2.alertInfo();  // 2http://+++.comfr1,fr2,fr3   
        //原型模式也不是没有缺点，首先，它省略了构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得了相同的属性值，
        //这样非常不方便，但这还是不是原型的最大问题，原型模式的最大问题在于共享的本性所导致的，
        //由于共享，因此因此一个实例修改了引用，另一个也随之更改了引用。因此我们通常不单独使用原型，而是结合原型模式与构造函数模式。
        console.log("^^^^^^^^^^ Part N. JS OO -- c. prototype. ^^^^^^^^^^^^^^^^");  
        
        
        // Part N. JS OO -- d. hybrid.
        //混合模式（原型模式 + 构造函数模式）
        function Blog4(name, url, friend) {
          this.name = name;
          this.url = url;
          this.friend = friend;
        }
        Blog4.prototype.alertInfo = function() {
          console.log(this.name + this.url + this.friend);
        }
        var blog = new Blog4('AAA', 'http://tools.aaa.net/', ['fr1', 'fr2', 'fr3']),
        blog2 = new Blog4('BBB', 'http://**.com', ['a', 'b']);
        blog.friend.pop();
        blog.alertInfo();  // AAAhttp://tools.aaa.net/fr1,fr2
        blog2.alertInfo();  // BBBhttp://**.coma,b
        //混合模式中构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。每个实例都会有自己的一份实例属性，
        //但同时又共享着方法，最大限度的节省了内存。另外这种模式还支持传递初始参数。
        //优点甚多。这种模式在ECMAScript中是使用最广泛、认同度最高的一种创建自定义对象的方法。
        console.log("^^^^^^^^^^ Part N. JS OO -- d. hybrid. ^^^^^^^^^^^^^^^^");  
        
        
        // Part N. JS OO -- e. initialization.
        //动态原型模式将所有信息封装在了构造函数中，而通过构造函数中初始化原型（仅第一个对象实例化时初始化原型），
        //这个可以通过判断该方法是否有效而选择是否需要初始化原型。
        function Blog5(name, url) {
          this.name = name;
          this.url = url;
          if (typeof this.alertInfo != 'function') {
            // 这段代码只执行了一次
            console.log('exe time');
            Blog5.prototype.alertInfo = function() {
              alert(thia.name + this.url);
            }
          }
        }       
        var blog = new Blog5('AAA', 'http://tools.aaa.net'),    //exe time
        blog2 = new Blog5('BBB', 'http:***.com');
        //可以看到上面的例子中只弹出一次窗，'exe time'，即当blog初始化时，
        //这样做blog2就不在需要初始化原型，对于使用这种模式创建对象，可以算是perfect了。
        console.log("^^^^^^^^^^ Part N. JS OO -- e. initialization. ^^^^^^^^^^^^^^^^");
        
        
        // Part O. timer
        var timer = null, SLEEP = 1000, interval=10;
        var timef = function ()
        {
            //var time = document.getElementById ('time');
            if ((interval--) == 1)
            {
                clearTimeout (timer);
                document.getElementById ('btn').removeAttribute("disabled");
                document.getElementById ('btn').value="获取验证码";
                interval=10;
                return;
            }
            document.getElementById ('btn').setAttribute("disabled", true);
            document.getElementById ('btn').value=interval+'s';
            timer = setTimeout (timef, SLEEP);
        }
        var reset=function(){
            document.getElementById ('btn').removeAttribute("disabled");
        }
        console.log("^^^^^^^^^^ Part O. timer ^^^^^^^^^^^^^^^^");
        
        
        // Part P. semicolon in Javascript
        //Js多个文件集成成一个文件后，压缩代码时避免发生语法错误，可以如下处理
        
        //一、js 前加分号
        //例如：;(function($){...此处代码...})();
        //Javascript中分号表示语句结束，在开头加上，是为了压缩的时候和别的方法分割一下，表示一个新的语句开始

        //二、js函数后加分号
        //例如
        //// 模块1, 前面有若干代码
        //var Manager = {
        //    prop: '',
        //    method: function () {
        //    }
        //}
        //// 模块2，开头是个立即执行函数
        (function () {
            // 代码
        })()
        //经过压缩后变成：  }}(function 那里，会被当成一个函数来执行，于是整体的解析就会出错了
        //var Manager = {prop: 'aaa',method: function (){}}(function () {})()
        //解决方法： 是在Manager函数后加分号.
        console.log("^^^^^^^^^^ Part P. semicolon in Javascript ^^^^^^^^^^^^^^^^");
        
        
        // Part Q. Release resources.
        //a. 释放javascript对象
        //在rich应用中，随着实例化对象数量的增加，内存消耗会越来越大。所以应当及时释放对对象的引用，让GC能够回收这些内存控件。
        //对象：
        //    obj = null
        //对象属性：
        //    delete obj.myproperty
        //数组item：使用数组的splice方法释放数组中不用的item
        
        //b. 释放dom元素占用的内存
        //将dom元素的innerHTML设置为空字符串，可以释放其子元素占用的内存。
        //在rich应用中，用户也许会在一个页面上停留很长时间，可以使用该方法释放积累得越来越多的dom元素使用的内存。
        console.log("^^^^^^^^^^ Part Q. Release resources. ^^^^^^^^^^^^^^^^");
        
        
        // Part R. avoid repetition.
        //重复使用的调用结果，事先保存到局部变量
        //避免多次取值的调用开销
        //var h1 = element1.clientHeight + num1;
        //var h2 = element1.clientHeight + num2;
        //可以替换为：
        //var eleHeight = element1.clientHeight;
        //var h1 = eleHeight + num1;
        //var h2 = eleHeight + num2;
        console.log("^^^^^^^^^^ Part R. avoid repetition. ^^^^^^^^^^^^^^^^");
        
        
        // Part S. number to string.
        //数字转换成字符串
        //般最好用”" + 1来将数字转换成字符串，虽然看起来比较丑一点，但事实上这个效率是最高的，性能上来说：
        //(“” +) > String() > .toString() > new String()
        console.log("100.01 to string is: "+(""+100.01));
        console.log("^^^^^^^^^^ Part S. number to string. ^^^^^^^^^^^^^^^^");
        
        
        //// Part T. Avoid global pollution.
        //全局变量应该全部字母大写，各单词之间用_下划线来连接。尽可能避免全局变量和函数, 尽量减少全局变量的使用，
        //因为在一个页面中包含的所有JavaScript都在同一个域中运行。
        //所以如果你的代码中声明了全局变量或者全局函数的话，
        //后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的。
        ////糟糕的全局变量和全局函数
        var current = null;
        function init(){
            //...
        }
        function change() {
            //...
        }
        function verify() {
            //...
        }
        ////解决办法有很多，Christian Heilmann建议的方法是：
        ////如果变量和函数不需要在“外面”引用，那么就可以使用一个没有名字的方法将他们全都包起来。
        (function(){
            var current = null;
            function init() {
                //...
            }
            function change() {
                //...
            }
            function verify() {
                //...
            }
        })();

        ////如果变量和函数需要在“外面”引用，需要把你的变量和函数放在一个“命名空间”中
        ////我们这里用一个function做命名空间而不是一个var，因为在前者中声明function更简单，而且能保护隐私数据
        var myNameSpace = function() {
            var current = null;
            function init() {
                //...
            }
            function change() {
                //...
            }
            function verify() {
                //...
            }
            //所有需要在命名空间外调用的函数和属性都要写在return里面
            return {
                init: init,
                //甚至你可以为函数和属性命名一个别名
                set: change
            };
        };
        console.log("^^^^^^^^^^ Part T. Avoid global pollution. ^^^^^^^^^^^^^^^^");
        
        
        //Part U. == and ===.
        //避免在if和while语句的条件部分进行赋值，如if (a = b)，应该写成if (a == b)，但是在比较是否相等的情况下，
        //最好使用全等运行符，也就是使用===和!==操作符会相对于==和!=会好点。
        //==和!=操作符会进行类型强制转换
        var valueA = "1";
        var valueB = 1;
        if (valueA == valueB) {
            console.log("Equal");
        }
        else {
            console.log("Not equal");
        }
        //output: "Equal"
        if (valueA === valueB) {
            console.log("Equal");
        }
        else {
            console.log("Not equal");
        }
        //output: "Not equal"
        console.log("^^^^^^^^^^ Part U. == and ===. ^^^^^^^^^^^^^^^^");
        
        
        //Part V. Avoid implicit boxing 
        //对string的方法调用，比如’xxx’.length，浏览器会进行一个隐式的装箱操作，将字符串先转换成一个String对象。
        //推荐对声明有可能使用String实例方法的字符串时，采用如下写法：
        var myString = new String('Hello World');
        console.log(myString.length);
        console.log("^^^^^^^^^^ Part V. Avoid implicit boxing. ^^^^^^^^^^^^^^^^");
        
        
        //Part W. Use Literals.
        var aTest = new Array(); //替换为
        var aTest = [];
        var aTest = new Object; //替换为
        var aTest = {};
        var reg = new RegExp(); //替换为
        var reg = /../;
        //如果要创建具有一些特性的一般对象，也可以使用字面量，如下：
        var oFruit = {};
        oFruit.color = "red";
        oFruit.name = "apple";
        //前面的代码可用对象字面量来改写成这样：
        var oFruit = { color: "red", name: "apple" };
        console.log("^^^^^^^^^^ Part W. Literals. ^^^^^^^^^^^^^^^^");
        
        
        //Part X. 巧用||和&&布尔运算符
        function eventHandler(e) {
            if (!e) e = window.event;
        }
        //可以替换为：
        function eventHandler2(e) {
            e = e || window.event;
        }

        var myobj;
        if (myobj) {
            doSomething(myobj);
        }
        //可以替换为：
        myobj && doSomething(myobj);
        console.log("^^^^^^^^^^ Part X. Usage of || and &&  ^^^^^^^^^^^^^^^^");
        
        
        //Part Y. float to int
        //很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，
        //我们应该使用Math.floor()或者Math.round()
        console.log(parseInt('100.5')+' '+Math.floor(100.5)+' '+Math.round(100.5));
        console.log("^^^^^^^^^^ Part Y. float to int ^^^^^^^^^^^^^^^^");
        
        
        //Part AA. operator +
        //使用+号时需谨慎
        //JavaScript 和其他编程语言不同的是，在 JavaScript 中，’+'除了表示数字值相加，字符串相连接以外，
        //还可以作一元运算符用，把字符串转换为数字。
        //因而如果使用不当，则可能与自增符’++’混淆而引起计算错误
        var valueA = 20;
        var valueB = "10";
        console.log(valueA + valueB);     //ouput: 2010 
        console.log(valueA + (+valueB));  //output: 30 
        console.log(valueA + +valueB);    //output:30 
        //console.log(valueA ++ valueB);     //Compile error
        console.log("^^^^^^^^^^ Part AA. operator + ^^^^^^^^^^^^^^^^");
        
    </script>
</head>
<body onunload="reset()">
    <div>Press F12 to view results in Console</div>
    <button type="button" id="testBtn">test</button>  
    <script>
        // Part L. new and event
        (function () {
            var Man=function(){
                var localInit=function(age){
                    this.sex="male";
                    this.age=age;
                    console.log(sex+' '+age);   //male 22
                };
                var _Hello_ok=function() {
                    console.log("您好，我测试attachEvent时间方法！");
                    console.log("^^^^^^^^^^ Part L. new and event ^^^^^^^^^^^^^^^^");
                };
                return{
                    ManInit:localInit,
                    Hello_ok: _Hello_ok
                }
            }
            var m2=new Man();
            m2.ManInit(22);
            var a = document.getElementById("testBtn");
            a.innerHTML  = "点我有事件";
            if (document.all) {//IE
                a.attachEvent("onclick", m2.Hello_ok);
            }
            else {//FF,Chrome，Safari
                a.addEventListener("click", m2.Hello_ok, false);
            }
        }());
        console.log("^^^^^^^^^^ Part L. new and event ^^^^^^^^^^^^^^^^");
    </script>
    
    <br/>
    <!-- Part O. timer -->
    <input onclick="timef();" id="btn" type="button" value="获取验证码" style="width:111px;height:11px"></button>
     
    <!-- Part Z. Call & Apply -->
    <br/>
    <a href="www.sina.com">Sina</a><br />
    <a href="www.sohu.com">Sohu</a><br />
    <a href="www.yahoo.com">Yahoo</a><br />
    <script>
        //Part Z. 3.It retrieves the slice function from an Array.
        //It then calls that function, but using the result of document.querySelectorAll
        //as the this object instead of an actual array.
        console.log([].slice.call(document.querySelectorAll('a')).join(','))
        console.log("^^^^^^^^^^ Part L. new and event ^^^^^^^^^^^^^^^^");
    </script>
</body>
</html>